using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NUnit.Framework;
using Saltarelle.Compiler.Compiler;
using Saltarelle.Compiler.JSModel;
using Saltarelle.Compiler.JSModel.Expressions;
using Saltarelle.Compiler.JSModel.Statements;
using Saltarelle.Compiler.JSModel.TypeSystem;
using Saltarelle.Compiler.OOPEmulation;
using System.Linq;
using Saltarelle.Compiler.Roslyn;
using Saltarelle.Compiler.ScriptSemantics;

namespace Saltarelle.Compiler.Tests.OOPEmulatorInvokerTests {
	[TestFixture]
	public class OOPEmulatorInvokerTests {
		private void AssertCorrect(IList<JsType> types, string expected, IOOPEmulator emulator, IMethodSymbol entryPoint, IReadOnlyList<AssemblyResource> resources = null) {
			var invoker = new OOPEmulatorInvoker(emulator, new MockMetadataImporter(), new MockErrorReporter());
			var result = invoker.Process(types, entryPoint, resources ?? new AssemblyResource[0]);
			var actual = OutputFormatter.Format(result, allowIntermediates: true).Replace("\r\n", "\n");
			Assert.That(actual, Is.EqualTo(expected.Replace("\r\n", "\n")));
		}

		private IList<JsType> Compile(string program) {
			var compilation = Common.CreateCompilation(program);
			var compiler = new Compiler.Compiler(new MockMetadataImporter(), new MockNamer(), new MockRuntimeLibrary(), new MockErrorReporter());
			return compiler.Compile(compilation).ToList();
		}

		[Test]
		public void InvokesTheCorrectMethodsAndAddsTheResultInTheCorrectOrder() {
			var types = Compile("class X {} class Y { void Main() {} }");
			AssertCorrect(types,
@"before(X, Y);
phase1(X);
phase1(Y);
phase2(X);
phase2(Y);
after(X, Y);
init(X);
init(Y);
{Y}.Main();
", new MockOOPEmulator {
	GetCodeBeforeFirstType  = (t, _) => new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier("before"), t.Select(x => JsExpression.Identifier(x.CSharpTypeDefinition.Name))) },
	GetStaticInitStatements = t      => new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier("init"), JsExpression.Identifier(t.CSharpTypeDefinition.Name)) },
	GetCodeAfterLastType    = (t, _) => new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier("after"), t.Select(x => JsExpression.Identifier(x.CSharpTypeDefinition.Name))) },
	EmulateType             = t      => new TypeOOPEmulation(new[] { new TypeOOPEmulationPhase(null, new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier("phase1"), JsExpression.Identifier(t.CSharpTypeDefinition.Name)) }),
	                                                            new TypeOOPEmulationPhase(null, new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier("phase2"), JsExpression.Identifier(t.CSharpTypeDefinition.Name)) }),
	                                                          })
}, types.Single(t => t.CSharpTypeDefinition.Name == "Y").CSharpTypeDefinition.GetMembers().OfType<IMethodSymbol>().Single(m => m.Name == "Main"));
		}

		[Test]
		public void StatementsForEachPhaseAreSortedIndividuallyFirstByDependencyThenByTypeName() {
			var asm = Common.CreateMockAssembly();
			var a = Common.CreateMockTypeDefinition("A", asm);
			var b = Common.CreateMockTypeDefinition("B", asm);
			var c = Common.CreateMockTypeDefinition("C", asm);
			var d = Common.CreateMockTypeDefinition("D", asm);

			var phase1Deps = new Dictionary<INamedTypeSymbol, IEnumerable<INamedTypeSymbol>> {
				{ a, new[] { b, c } },
				{ b, new[] { d } },
				{ c, new[] { d } },
				{ d, new INamedTypeSymbol[0] },
			};
			var phase2Deps = new Dictionary<INamedTypeSymbol, IEnumerable<INamedTypeSymbol>> {
				{ a, new[] { b, d } },
				{ b, new[] { c } },
				{ c, new INamedTypeSymbol[0] },
				{ d, new[] { c } },
			};
			var phase3Deps = new Dictionary<INamedTypeSymbol, IEnumerable<INamedTypeSymbol>> {
				{ a, new INamedTypeSymbol[0] },
				{ b, new INamedTypeSymbol[0] },
				{ c, new INamedTypeSymbol[0] },
				{ d, new INamedTypeSymbol[0] },
			};

			AssertCorrect(new[] { new JsClass(a), new JsClass(b), new JsClass(c), new JsClass(d) },
@"D(1);
B(1);
C(1);
A(1);
C(2);
B(2);
D(2);
A(2);
A(3);
B(3);
C(3);
D(3);
", new MockOOPEmulator {
	EmulateType = t => new TypeOOPEmulation(new[] {
		new TypeOOPEmulationPhase(phase1Deps[t.CSharpTypeDefinition], new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier(t.CSharpTypeDefinition.Name), JsExpression.Number(1)) }),
		new TypeOOPEmulationPhase(phase2Deps[t.CSharpTypeDefinition], new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier(t.CSharpTypeDefinition.Name), JsExpression.Number(2)) }),
		new TypeOOPEmulationPhase(phase3Deps[t.CSharpTypeDefinition], new[] { (JsStatement)JsExpression.Invoke(JsExpression.Identifier(t.CSharpTypeDefinition.Name), JsExpression.Number(3)) }),
	})
}, null);
		}

		[Test]
		public void SortingByNameWorksWithNamespaces() {
			var asm = Common.CreateMockAssembly();
			var names = new[] { "A", "B", "C", "A.B", "A.BA", "A.C", "A.BAA.A", "B.A", "B.B", "B.C", "B.A.A", "B.A.B", "B.B.A" };
			var rnd = new Random(42);
			var types = names.Select(n => new { n, r = rnd.Next() }).OrderBy(x => x.r).Select(x => (JsType)new JsClass(Common.CreateMockTypeDefinition(x.n, asm))).ToList();

			AssertCorrect(types, string.Join("\n", names.Select(x => x.Replace(".", "_") + ";")) + "\n", new MockOOPEmulator { EmulateType = t => new TypeOOPEmulation(new[] { new TypeOOPEmulationPhase(null, new[] { (JsStatement)JsExpression.Identifier(t.CSharpTypeDefinition.Name.Replace(".", "_")) }) }) }, null);
		}

		[Test]
		public void SortByDependencyWorksWithGenericTypes() {
			var types = Compile(
@"public abstract class Base {}
public abstract class EBase : Base { }
public abstract class GenericBase<T> : EBase { }
public sealed class C : GenericBase<object> {}");
			AssertCorrect(types,
@"Base;
EBase;
C;
GenericBase;
", new MockOOPEmulator { EmulateType = t => new TypeOOPEmulation(new[] { new TypeOOPEmulationPhase(t.CSharpTypeDefinition.GetAllBaseTypes().Select(b => (INamedTypeSymbol)b.OriginalDefinition).Where(b => b.TypeParameters.Length == 0), new[] { (JsStatement)JsExpression.Identifier(t.CSharpTypeDefinition.Name) }) }) }, null);
		}

		[Test]
		public void AnErrorIsIssuedIfTheMainMethodHasParameters() {
			var er = new MockErrorReporter();
			var invoker = new OOPEmulatorInvoker(new MockOOPEmulator(), new MockMetadataImporter(), er);
			var compilation = Common.CreateCompilation("class MyClass { public void Main(string[] args) { } }", new[] { MetadataReference.CreateFromFile(typeof(object).Assembly.Location) });

			var myClass = compilation.GetTypeByMetadataName("MyClass");
			invoker.Process(new[] { new JsClass(myClass) }, (IMethodSymbol)myClass.GetMembers("Main").Single(), new AssemblyResource[0]);

			Assert.That(er.AllMessages, Has.Count.EqualTo(1));
			Assert.That(er.AllMessages.Any(m => m.Code == 7800 && (string)m.Args[0] == "MyClass.Main"));
		}

		[Test]
		public void AnErrorIsIssuedIfTheMainMethodIsNotImplementedAsANormalMethod() {
			var er = new MockErrorReporter();
			var invoker = new OOPEmulatorInvoker(new MockOOPEmulator(), new MockMetadataImporter { GetMethodSemantics = m => m.Name == "Main" ? MethodScriptSemantics.InlineCode("X") : MethodScriptSemantics.NormalMethod(m.Name) }, er);
			var compilation = Common.CreateCompilation("class MyClass { public void Main() { } }", new[] { MetadataReference.CreateFromFile(typeof(object).Assembly.Location) });
			
			var myClass = compilation.GetTypeByMetadataName("MyClass");
			invoker.Process(new[] { new JsClass(myClass) }, (IMethodSymbol)myClass.GetMembers("Main").Single(), new AssemblyResource[0]);
			
			Assert.That(er.AllMessages, Has.Count.EqualTo(1));
			Assert.That(er.AllMessages.Any(m => m.Code == 7801 && (string)m.Args[0] == "MyClass.Main"));
		}

		[Test]
		public void StaticInitStatementsAreSortedByAllReferencesInTypes() {
			var types = Compile(
@"public class C6 { static C6() { var x6 = typeof(C5); } }
public class C1 { static C1() { int x1 = 0; } }
public class C4 { public static void M() { var t = typeof(C3); } static C4() { int x4 = 0; } }
public class C2 { public C2() { var t = typeof(C1); } static C2() { int x2 = 0; } }
public class C5 { public void M() { var t = typeof(C4); } static C5() { int x5 = 0; } }
public class C3 { public C3(int x) { var t = typeof(C2); } static C3() { int x3 = 0; } }
");
			AssertCorrect(types,
@"C1;
C2;
C3;
C4;
C5;
C6;
", new MockOOPEmulator {
	GetStaticInitStatements = t => new[] { (JsStatement)JsExpression.Identifier(t.CSharpTypeDefinition.Name) }
}, null);
		}

		[Test]
		public void StaticMethodsOnlyAreUsedAsTieBreakersWhenCyclicDependenciesOccur() {
			var types = Compile(
@"public class C5 { public void M() { var t = typeof(C3); } static C5() { int x5 = 0; } }
public class C3 { [System.Runtime.CompilerServices.ScriptName(""someName"")] public C3(int x) { var t = typeof(C2); } static C3() { var x3 = typeof(C2); } }
public class C2 { public C2() { var t = typeof(C4); } static C2() { int x2 = 0; } }
public class C4 { public void M1() { var t = typeof(C3); } public static void M2() { var t = typeof(C3); } static C4() { int x4 = 0; } }
public class C1 { static C1() { int x1 = 0; } }");

			AssertCorrect(types,
@"C1;
C2;
C3;
C4;
C5;
", new MockOOPEmulator {
	GetStaticInitStatements = t => new[] { (JsStatement)JsExpression.Identifier(t.CSharpTypeDefinition.Name) }
}, null);
		}

		[Test]
		public void StaticInitStatementsOnlyAreUsedAsATieBreakerWhenCyclicDependenciesInStaticMethodsOccur() {
			var types = Compile(
@"public class C5 { static void M() { var t = typeof(C3); } static C5() { int x5 = 0; } }
public class C3 { static void M() { var t = typeof(C2); } static C3() { var x3 = typeof(C2); } }
public class C2 { static void M() { var t = typeof(C4); } static C2() { int x2 = 0; } }
public class C4 { static void M() { var t = typeof(C3); } static C4() { var x4 = typeof(C3); } }
public class C1 { static C1() { int x1 = 0; } }");
			AssertCorrect(types,
@"C1;
C2;
C3;
C4;
C5;
", new MockOOPEmulator {
	GetStaticInitStatements = t => new[] { (JsStatement)JsExpression.Identifier(t.CSharpTypeDefinition.Name) }
}, null);
		}

		[Test]
		public void CyclesInDependencyGraphAreHandledGracefully() {
			var asm = Common.CreateMockAssembly();
			var a = Common.CreateMockTypeDefinition("A1", asm);
			var b = Common.CreateMockTypeDefinition("B1", asm);
			var c = Common.CreateMockTypeDefinition("C1", asm);
			var d = Common.CreateMockTypeDefinition("D1", asm);

			var deps = new Dictionary<INamedTypeSymbol, IEnumerable<INamedTypeSymbol>> {
				{ a, new[] { b } },
				{ b, new[] { c } },
				{ c, new[] { a } },
				{ d, new INamedTypeSymbol[0] },
			};

			var er = new MockErrorReporter();
			var invoker = new OOPEmulatorInvoker(new MockOOPEmulator { EmulateType = t => new TypeOOPEmulation(new[] { new TypeOOPEmulationPhase(deps[t.CSharpTypeDefinition], new[] { (JsStatement)JsExpression.Null }) }) }, new MockMetadataImporter(), er);
			invoker.Process(new[] { new JsClass(a), new JsClass(b), new JsClass(c), new JsClass(d) }, null, new AssemblyResource[0]);

			Assert.That(er.AllMessages, Has.Count.EqualTo(1));
			Assert.That(er.AllMessages.Any(m => m.Code == 7802 && ((string)m.Args[0]).Contains("A1") && ((string)m.Args[0]).Contains("B1") && ((string)m.Args[0]).Contains("C1")));
		}

		[Test]
		public void ResourcesAreIncluded() {
			var a = new AssemblyResource("a", true, () => new MemoryStream());
			var b = new AssemblyResource("b", false, () => new MemoryStream());

			Action<IReadOnlyList<AssemblyResource>> asserter = r => {
				Assert.That(r[0], Is.SameAs(a));
				Assert.That(r[1], Is.SameAs(b));
			};

			var er = new MockErrorReporter();
			var invoker = new OOPEmulatorInvoker(new MockOOPEmulator { GetCodeBeforeFirstType = (_, r) => { asserter(r); return new JsStatement[0]; }, GetCodeAfterLastType = (_, r) => { asserter(r); return new JsStatement[0]; } }, new MockMetadataImporter(), er);
			invoker.Process(new JsType[0], null, new[] { a, b });
			Assert.That(er.AllMessages, Is.Empty);
		}
	}
}
